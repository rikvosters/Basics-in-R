filter(year == 1945)
babynames %>%
filter(name == "Adolf")
babynames %>%
filter(name == "Dwight")
babynames %>%
filter(name == "Dwight") %>%
plot(prop)
babynames %>%
filter(name == "Dwight") %>%
plot(babynames$prop)
babynames %>%
filter(name == "Dwight") %>%
ggplot(aes(x = year, y = prop))
babynames %>%
filter(name == "Dwight") %>%
ggplot(aes(x = year, y = prop)) %>%
geom_line()
babynames %>%
filter(name == "Dwight") %>%
ggplot(aes(x = year, y = prop)) +
geom_line()
babynames %>%
filter(name == "Dwight") %>%
filter(sex == "M") %>%
ggplot(aes(x = year, y = prop)) +
geom_line()
babynames %>%
filter(name == "Dwight") %>%
filter(sex == "M")
babynames %>%
filter(name == "Dwight") %>%
filter(sex == "F")
babynames %>%
filter(name == "Dwight") %>%
filter(sex == "F") %>%
ggplot(aes(x = year, y = prop)) +
geom_line()
babynames %>%
filter(name == "Dwight") %>%
filter(sex == "M") %>%
ggplot(aes(x = year, y = prop)) +
geom_line()
# often serves as input for a plot (ggplot: see later)
babynames %>%
filter(name == "Donald") %>%
filter(sex == "M") %>%
ggplot(aes(x = year, y = prop)) +
geom_line()
babynames %>%
filter(name == "Donald") %>%
filter(sex == "M") %>%
ggplot(aes(x = year, y = prop)) +
geom_line()
max(babynames$year)
babynames %>%
filter(name == "George") %>%
filter(sex == "M") %>%
ggplot(aes(x = year, y = prop)) +
geom_line()
babynames
sum(n)
sum(babynames$n)
babynames %>%
mutate(prop_overall = n/sum(n))
babynames %>%
mutate(prop_overall = n/sum(n)) -> babynames
babynames %>%
mutate(name_gendered = paste0(name, "_", sex))
babynames %>%
select(year, sex, name)
babynames %>%
arrange(prop, year)
babynames %>%
arrange(prop)
babynames %>%
arrange(prop_overall)
babynames %>%
arrange(rev(prop_overall))
babynames %>%
arrange(!prop_overall)
babynames %>%
arrange(rev(prop_overall))
babynames %>%
arrange(name)
babynames %>%
arrange(name)
babynames %>%
arrange(n, year)
babynames %>%
arrange(rev(n), year)
babynames %>%
arrange(rev(n), year) %>%
print(n=500)
babynames %>%
arrange(n, year)
babynames %>%
select(year == 1950) %>%
arrange(name)
babynames %>%
select(year == 1950)
babynames %>%
select(year == 1950) %>%
arrange(name)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
###                                                                     ###
###    Workshop: Basics in R for people who are afraid of computers     ###
###                  DSh - VUB - September 2020                         ###
###             Rik Vosters - Vrije Universiteit Brussel                ###
###             Rik.Vosters@vub.ac.be | www.rikvosters.be               ###
###                                                                     ###
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
### 1. GETTING STARTED -----
# How does R work?
# Type things in script and send to console
"hello world"
print("hello world")
# Basic functions in R: addition, subtraction, etc.
2+7
2*7
2 + 7
# Notice how anything behind the hash is a comment and is not processed
2+7 # comment
2+7 # +100
2+7   +100
# Assigning values
a <- 2+7  # assign  (pro tip Mac: OPTION + '-')
# cf. 'Environment' window
a
# Alternative:
a = 2+7
# Operations on save values
a - 3
a <- a - 3 # overwrite
a
10*a+(1/3*a)
A # careful: R is case sensitive
# Define a sequence of elements (= vector)
b <- c(2, 4, 6) # notice: function c()
b
a+b
c <- c(a, b) # again, combine
c
# Some other basic functions
mean(c)
median(c)
min(b)
max(b)
plot(c) # plot -- cf. 'Plots' window
barplot(c)
# Embedded functions
plot(c(c, b)) # function combine inside function plot
barplot(c(mean(b), mean(c)))
# Syntax: three ways of writing it out
# most economical:
barplot(c(mean(b), mean(c)))
# most clear:
first_mean <- mean(b)
second_mean <- mean(c)
means_to_plot <- c(first_mean, second_mean)
barplot(means_to_plot)
# middle ground
means_to_plot <- c(mean(b), mean(c))
barplot(means_to_plot)
# Pro tip: use 'TAB'
# Typical structure of a function:
# function(x, y, option=FALSE)
# Need help?
?plot  # cf. 'Help' window
?max()
?barplot()
# Starting routine
# clear working space
rm(list=ls(all=TRUE))
# set working directory
setwd("")
setwd("/Users/rikvosters/Dropbox/@ Documenten/Colleges - courses/_Gastcolleges/2020.05 DSh workshop - Basics in R/Basics-in-R")
getwd()
# Windows: setwd(choose.dir())
# Linux: tk_choose.files() does same thing - library(tcltk)
# also possible: CTRL + SHIFT + H
# also possible: RStudio Project
# Working with packages
# first, once:
install.packages("stylo")
# then, every session before using it or at the beginning of the script:
library(stylo)
# want to know more about the package?
help(package=stylo) # or write in 'Help' window
install.packages("tidyverse") # once
library(tidyverse)
# alternatively:
# Packages > Install Packages | Tools > Install Packages
# Select a CRAN Mirror (Austria)
# Select a package or type the name of a package
# Use library(package) to load it
# see also: 'Packages' window
####--- | exercise: create new file  ---####
# - Create a new script file in RStudio (File > New file > R Script)
# - Enter the following in this new script file
# x <- c(1530, 1540, 1550, 1560, 1570, 1580, 1590, 1600)
# x
# y <- c(4, 9, 17, 48, 78, 92, 96, 98)
# y
# plot(x, y)
# - Save this file (File > Save as > …)
# - Now run your code: either line by line, or by selecting all
#   of the lines and hitting 'CMD + enter' once
#   (or clicking the 'Run' button in the toolbar at the top of your script file)
# - Go to the plot window, and save the plot you created
#   (Export > Save plot as PDF > …; change the working directory if necessary)
# - Inspect the output you generated
####--- | solution: create new file  ---####
x <- c(1530, 1540, 1550, 1560, 1570, 1580, 1590, 1600)
x
y <- c(4, 9, 17, 48, 78, 92, 96, 98)
y
plot(x, y)
####--- | exercise: hours of sleep  ---####
# - Assign values to create two vectors: one called 'sleep_week' where you input 5 numeric values for the (actual or ficticious) number of hours of sleep you got per weekday last week, and one called 'sleep_weekend'where you input 2 numeric values for the number of hours of sleep you got per day of the weekend last week. Make an estimation up to one decimal point (e.g. 8.5).
# - Create a new vector called 'weekend_zzz', for which you (automatically) calculate on average how many more hours of sleep you get in the weekend compared to during the week.
####--- | solution: hours of sleep  ---####
sleep_week <- c(7, 6, 5.5, 8, 6)
sleep_weekend <- c(5,11)
weekend_zzz <- mean(sleep_weekend) - mean(sleep_week)
weekend_zzz
### 2. DATA STRUCTURES -----
# Most important data structures:
# Vectors: numeric, character, logical
# Dataframes (and tibble)
# Lists
### 2.1 Numeric vectors -----
# create a vector
vecky <- c(90, 95, 100, 105, 110)
vecky
# subsetting - access one specific element of that vector
vecky[1]
vecky[1:3]
vecky[c(2,3)]
# generating vectors
1:35
1:1000
seq(from = 7, to = 9.5, by = 0.25)
rep(1:4, 3)
rep("abc", 3) # also for non-numerical vectors, cf. below
# some more data
wordcounts <- rnorm(100, mean=180, sd=40) # Generate normally distributed
# data with a standard deviation
# of 40 around a mean score of 100
wordcounts
# round
round(wordcounts, 0)
wordcounts <- round(wordcounts, 0)
wordcounts
# sort
sort(wordcounts)
sort(wordcounts, decreasing=T)
# visually
plot(wordcounts)
plot(sort(wordcounts))
hist(wordcounts)
# some other useful functions
length(wordcounts)
sum(wordcounts)
sum(wordcounts, vecky)
max(wordcounts); min(wordcounts)
rev(wordcounts)
# more subsetting: logical expressions
wordcounts
sort(wordcounts, decreasing=T)
wordcounts[wordcounts>=200] # gives you the actual elements from the
# dataframe matching the logical expression
# compare:
wordcounts>=200 # logical vector
wordcounts[wordcounts>=200]
#     <   Smaller than
#     <=  Smaller than or equal to
#     >   Larger than
#     >=  Larger than or equal to
#     ==  Equal to
#     !=  Unequal to
wordcounts[wordcounts != 210]
wordcounts[wordcounts >= 210]
# how many elements in vector?
length(wordcounts[wordcounts >= 210])
wordcounts[wordcounts > 210 | wordcounts < 150] # | = OR
wordcounts[wordcounts < 175 & wordcounts > 150] # & = AND
benchmark <- 210:500 # define a vector with a benchmark range
benchmark
wordcounts[wordcounts %in% benchmark]   # select all wordcount values
# that occur in that range
wordcounts[!wordcounts %in% benchmark]  # select all wordcount values
# that do NOT occur in that range
####--- | exercise: hours of sleep (bis) ---####
# 1. Empty the work space.
# 2. Create one vector with the (estimated) average hours of sleep you had for each night last week. Make an estimation up to one decimal point (e.g. 8.5), starting with Monday and ending with Sunday (i.e. 7 numbers in total)
# 3. Calculate your mean number of hours of sleep based on this vector. Round to two decimal points.
# 4. Calculate with a function how many nights you had less than 7 hours of sleep.
# 5. Calculate in how many percent of all nights last week you had 8 hours or more of sleep. (Tip: percent = (x/y)*100)
# 6. Calculate the difference between your average hours of sleep during the week (i.e. Monday night till Friday night) versus in the weekend (i.e. Saturday and Sunday night). Use a subset of the first 5 and the last 2 elements in your vector.
####--- | solution: hours of sleep (bis) ---####
rm(list=ls(all=TRUE))
sleep <- c(7.0, 6.5, 6.0, 8.5, 6.5, 6.0, 5.5)
mean(sleep)
round(mean(sleep),2)
av <- mean(sleep)
round(av,2)
length(slaap[sleep < 7])
(length(slaap[sleep >= 8])/7)*100
week <- round(mean(sleep[1:5]),2)
week
weekend <- round(mean(sleep[6:7]),2)
weekend
diff <- week - weekend; diff
#### 2.2 Character vectors ####
# create a vector
vecky2 <- c("Colorless", "green", "ideas", "sleep", "furiously")
vecky2
vecky3 <- c("Time flies like an arrow", "Fruit flies like a banana")
vecky3
# no spaces in vector names - use underscore or dot
vekkie test <- c("Aa", "Bb", "Cc")
vekkie_test <- c("Aa", "Bb", "Cc")
# subsetting - access one specific element of that vector
vecky2[1:3]
vecky2[c(2,4)]
# stoplists
stoplist <- c("green", "linguistics", "sleep", "Chomsky") # define stoplist to test vector against for subsetting
vecky2 %in% stoplist  # Does each element of vector vecky2 occur in
# the stoplist? (returns logical vector)
vecky2[vecky2 %in% stoplist] # Which elements of vecky2 occur in the stoplist?
vecky2[!vecky2 %in% stoplist] # Opposite: which elements of vecky2
# do not occur in stoplist?
# Useful for subsetting your corpus data or
# throwing out unwanted items (cf. later)
# other useful functions:
nchar(vecky2)
toupper(vecky2)
tolower(vecky2)
substr(vecky2, 1, 3)
# types and tokens
konami_code <- c("up", "up", "down", "down", "left", "right", "left", "right", "B", "A", "start")
konami_code
unique(konami_code) # types of the vector
table(konami_code) # type frequencies
sort(table(konami_code), decreasing=T) # sorted - basic frequency list!
# missing values = NA
konami_missing <- c("up", NA, "down", "down", "left", "right", "left", "right", "B", "A", "start")
table(konami_missing)
####--- | exercise: Belgian Dutch words ---####
# Below is a selection of words that are considered to be non-standard Belgian Dutch, according to one particular prescriptivist language advice guidebook. The actual list is longer, but we just show the words starting with the letters A and B for practical reasons.
# > "Afgevaardigd Beheerder", "Ajuin", "Alcoholieker", "Alleszins", "Ardeens", "Autostrade", "Autotaks", "Allergisch Aan", "Aftrekker", "Afkuisen", "Baxter", "Bedanking", "Bedelen", "Beenhouwer", "Begankenis", "Bekwaam Om", "Benadeligen", "Bereide Schotel", "Beschaamd", "Beteugelen", "Betoelagen", "Betonneren", "Betrachten", "Betrachting", "Betrouwen", "Bic", "Bijhuis", "Binnendoen", "Binnenkoer", "Baxter", "Botermelk", "Boerenbuiten", "Brol", "Brossen", "Buitensmijten", "Bureel"
# 1. Load the list of words into your workspace. Don't type all of them, but use copy and paste!
# 2. Convert the text to lower case.
# 3. Make a frequency table of the words in the list to check of there are no words accidentally listed twice.
# 4. If necessary, remove double words from the list.
# 5. Try to use subsetting to find our if the words 'beschaamd', 'bisser' and 'boterkoek' appear in the list of the non-standard Belgian Dutch words.
####--- | solution: Belgian Dutch words ---####
# load
belgicisms <- c("Afgevaardigd Beheerder", "Ajuin", "Alcoholieker", "Alleszins", "Ardeens", "Autostrade", "Autotaks", "Allergisch Aan", "Aftrekker", "Afkuisen", "Baxter", "Bedanking", "Bedelen", "Beenhouwer", "Begankenis", "Bekwaam Om", "Benadeligen", "Bereide Schotel", "Beschaamd", "Beteugelen", "Betoelagen", "Betonneren", "Betrachten", "Betrachting", "Betrouwen", "Bic", "Bijhuis", "Binnendoen", "Binnenkoer", "Baxter", "Botermelk", "Boerenbuiten", "Brol", "Brossen", "Buitensmijten", "Bureel")
# convert to lower
belgicisms <- tolower(belgicisms)
# table for double entries
sort(table(belgicisms)) # baxter = 2x
# remove double entries
belgicisms <- unique(belgicisms)
# check if five words appear in list
words_to_check <- c("beschaamd", "bisser", "boterkoek")
words_to_check[words_to_check %in% belgicisms] # cf.: words_to_check %in% belgicisms
### 2.3 Dataframes -----
# A dataframe consists of different vectors of the same length
col1 <- c("Aldrych", "Theobald", "Cadwell", "Ogden", "Roderick", "Rypley", "Marston", "Jimmy")
col2 <- c("/r/", "/R/", "/R/", NA, "/r/", "/r/", "/R/", "/R/")
col3 <- c(21, 98, 46, 17, 91, 100, 76, 0)
col4 <- c(TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE)
# Combining these three vectors with the function data.frame gives us one dataframe called 'OE'
OE <- data.frame(col1, col2, col3, col4)
# You can add column names (= Variable names) to the dataframe
names(OE) <- c("Scribe","Pronunciation","Reaction_time", "Verified")
OE # access entire dataframe
## Subsetting: same logic, but two dimensions: [rows, columns]
OE
OE[1,] # first row of dataframe OE
OE[,1] # first column of dataframe OE; same as:
# same, but easier (columns)
OE$Scribe
OE$Reaction_time
OE[,1:3] # what will we get here?
OE[3:6,1:2] # and here?
## Functions: Functions operating on vectors also work on columns/factors in a data frame
# … both numerical:
mean(OE$Reaction_time)
plot(sort(OE$Reaction_time))
# … and character-based:
toupper(OE$Scribe)
table(OE$Pronunciation)
## More subsetting: we can also subset the whole dataframe based on selection criteria applied to specific factors
OE[OE$Reaction_time > 25,]  # Subset the dataframe OE with all the entries
# (rows) which have a reaction time of more than 25
# Mind the comma!
OE[OE$Scribe != "Roderick",]
OE[OE$Reaction_time > 25 & OE$Pronunciation == "/r/",]
# head()
# see only first 6 rows
head(OE) # identical as OE[1:6,]
head(OE,3) # specify number of rows
### 2.4 Importing data -----
# Several methods, depending on format of source
# TYPE 1: CSV - comma-separated (text) files
# be sure to set the working directory (or give a full path)
setwd("/Users/rikvosters/Dropbox/@ Documenten/Colleges - courses/_Gastcolleges/2020.05 DSh workshop - Basics in R/Basics-in-R")
# load
shark <- read.csv("SharkAttacks_sample.csv") # based on: https://data.world/shruti-prabhu/shark-attacks
head(shark)
# options:
read.csv("SharkAttacks_sample.csv", header = T, sep = ",", encoding = "UTF-8", strip.white = T, dec = ".")
# separator value = often '\t' (tab-delimited)
# also: read.delim() instead of read.csv
# alternative:
# - Import tool in RStudio:
#   `File` > `Import dataset` > `From Text (base)`
# TYPE 2: Internet files with a specific URL
shark <- read.csv("https://raw.githubusercontent.com/rikvosters/Basics-in-R/master/SharkAttacks_sample.csv") # no need to set working directory
head(shark)
# TYPE 3: Excel spreadsheets
library(readxl)  # first (just once): install.packages(readxl)
read_excel("SharkAttacks.xlsx")
# loads it as special type of dataframe: tibble (cf. infra)
# TYPE 4: R package
# some data is just available in a ready-made R package
# e.g. baby names
library(babynames) # first (just once): install.packages(babynames)
bb <- babynames
bb # also tibble
####--- | exercise: LEGO ---####
# Load a dataset called 'LEGOsets.csv', which contains an overview of all official LEGO sets (source: https://www.kaggle.com/rtatman/lego-database). You can either load it from the workshop folder, or from an online url (https://raw.githubusercontent.com/rikvosters/Basics-in-R/master/LEGOsets.csv). Explore the first six rows of the dataframe. Then make a histogram of the variable 'year', to see how many sets were released each year. Next, check with a function when the first official set was released. Finally, extract the names of all LEGO sets released in 1955.
####--- | solution: LEGO ---####
# load data (offline)
lego <- read.csv("LEGOsets.csv")
# load data (online)
lego <- read.csv("https://raw.githubusercontent.com/rikvosters/Basics-in-R/master/LEGOsets.csv")
# first six rows
head(lego)
# histogram
hist(lego$year)
# first
min(lego$year)
# names in 1955
lego$name[lego$year == 1955]
####--- | exercise: catholic fertility ---####
# Install and load the package called 'datasets'. This package contains a dataset called 'swiss', which contains Swiss fertility and socioeconomic indicators from the year 1888. Save this dataset in your working environment as a new dataframe called 'helvetica', and explore it by looking at the first 10 rows. Now extract the rows only for those districts where more than 50% of the population is catholic, and calculate the mean fertility rate for these predominantly catholic districts. Now compare it to the mean fertility rate of districts with 50% of catholics or less.
####--- | solution: catholic fertility ---####
# install and load
library(datasets) # once: install.packages("datasets")
# save as new df
helvetica <- swiss
# first ten rows
head(helvetica, 10)
# rows for districts where Catholic > 50
helvetica[helvetica$Catholic > 50,]
# mean fertility rate in these catholic districts compared to districts with Catholic <= 50
mean(helvetica[helvetica$Catholic > 50,]$Fertility)
mean(helvetica[helvetica$Catholic <= 50,]$Fertility)
# alternative - new dataframe based on subset:
helvetica_catolica <- helvetica[helvetica$Catholic > 50,]
helvetica_heretica <- helvetica[helvetica$Catholic <= 50,]
mean(helvetica_catolica$Fertility)
mean(helvetica_heretica$Fertility)
### 2.5 An alternative approach: tidyverse -----
# new kid on the block: tidyverse (tidyverse.org)
# popular set of packages (dplyr, ggplot, tidyr, … )
# easier to get started, but harder for some things
# 'tidy' data:
#    1. each column is a variable
#    2. each row is an observation
library(tidyverse)
# Some innovations:
# 1. Tibbles instead of dataframes
bb <- babynames
bb
# faster and easier to work with; always prints 10 cases and as many columns as fit on screen
# to see more:
print(bb, n = 50)
# possible to make a dataframe into a tibble:
OE_tibble <- tibble(OE)
OE_tibble
# and back
OE <- data.frame(OE_tibble)
OE
# 2. Pipe character %>%
# for sequential code rather than embedded functions (CMD + shift + M)
wordcounts %>% sort() %>% plot()
# is the same as:
plot(sort(wordcounts))
round(mean(babynames$n))
# is the same as:
babynames$n %>%
mean() %>%
round()
# 3. 'Plying' your data (dplyr)
# filter(): similar to subsetting, selecting cases (rows) based on their values
babynames %>%
filter(name == "Dwight")
babynames %>%
filter(name == "Dwight") %>%
filter(sex == "M")
# often serves as input for a plot (ggplot: see later)
babynames %>%
filter(name == "Dwight") %>%
filter(sex == "M") %>%
ggplot(aes(x = year, y = prop)) +
geom_line()
